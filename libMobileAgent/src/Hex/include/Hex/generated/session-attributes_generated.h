// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SESSIONATTRIBUTES_COM_NEWRELIC_MOBILE_FBS_H_
#define FLATBUFFERS_GENERATED_SESSIONATTRIBUTES_COM_NEWRELIC_MOBILE_FBS_H_

#include <flatbuffers/flatbuffers.h>

namespace com {
namespace newrelic {
namespace mobile {
namespace fbs {

struct StringSessionAttribute;
struct StringSessionAttributeT;

struct LongSessionAttribute;
struct LongSessionAttributeT;

struct DoubleSessionAttribute;
struct DoubleSessionAttributeT;

struct BoolSessionAttribute;
struct BoolSessionAttributeT;

struct StringSessionAttributeT : public flatbuffers::NativeTable {
  typedef StringSessionAttribute TableType;
  std::string name;
  std::string value;
  StringSessionAttributeT() {
  }
};

struct StringSessionAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringSessionAttributeT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const StringSessionAttribute *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  flatbuffers::String *mutable_value() {
    return GetPointer<flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
  StringSessionAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StringSessionAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringSessionAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StringSessionAttribute::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringSessionAttribute::VT_VALUE, value);
  }
  StringSessionAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringSessionAttributeBuilder &operator=(const StringSessionAttributeBuilder &);
  flatbuffers::Offset<StringSessionAttribute> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<StringSessionAttribute>(end);
    fbb_.Required(o, StringSessionAttribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<StringSessionAttribute> CreateStringSessionAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringSessionAttributeBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringSessionAttribute> CreateStringSessionAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *value = nullptr) {
  return com::newrelic::mobile::fbs::CreateStringSessionAttribute(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      value ? _fbb.CreateString(value) : 0);
}

flatbuffers::Offset<StringSessionAttribute> CreateStringSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const StringSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LongSessionAttributeT : public flatbuffers::NativeTable {
  typedef LongSessionAttribute TableType;
  std::string name;
  int64_t value;
  LongSessionAttributeT()
      : value(0) {
  }
};

struct LongSessionAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LongSessionAttributeT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const LongSessionAttribute *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool mutate_value(int64_t _value) {
    return SetField<int64_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  LongSessionAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LongSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LongSessionAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LongSessionAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LongSessionAttribute::VT_NAME, name);
  }
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(LongSessionAttribute::VT_VALUE, value, 0);
  }
  LongSessionAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongSessionAttributeBuilder &operator=(const LongSessionAttributeBuilder &);
  flatbuffers::Offset<LongSessionAttribute> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<LongSessionAttribute>(end);
    fbb_.Required(o, LongSessionAttribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<LongSessionAttribute> CreateLongSessionAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int64_t value = 0) {
  LongSessionAttributeBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LongSessionAttribute> CreateLongSessionAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int64_t value = 0) {
  return com::newrelic::mobile::fbs::CreateLongSessionAttribute(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      value);
}

flatbuffers::Offset<LongSessionAttribute> CreateLongSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const LongSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DoubleSessionAttributeT : public flatbuffers::NativeTable {
  typedef DoubleSessionAttribute TableType;
  std::string name;
  double value;
  DoubleSessionAttributeT()
      : value(0.0) {
  }
};

struct DoubleSessionAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleSessionAttributeT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const DoubleSessionAttribute *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool mutate_value(double _value) {
    return SetField<double>(VT_VALUE, _value, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  DoubleSessionAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DoubleSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DoubleSessionAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DoubleSessionAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DoubleSessionAttribute::VT_NAME, name);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(DoubleSessionAttribute::VT_VALUE, value, 0.0);
  }
  DoubleSessionAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleSessionAttributeBuilder &operator=(const DoubleSessionAttributeBuilder &);
  flatbuffers::Offset<DoubleSessionAttribute> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<DoubleSessionAttribute>(end);
    fbb_.Required(o, DoubleSessionAttribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<DoubleSessionAttribute> CreateDoubleSessionAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    double value = 0.0) {
  DoubleSessionAttributeBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleSessionAttribute> CreateDoubleSessionAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    double value = 0.0) {
  return com::newrelic::mobile::fbs::CreateDoubleSessionAttribute(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      value);
}

flatbuffers::Offset<DoubleSessionAttribute> CreateDoubleSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const DoubleSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BoolSessionAttributeT : public flatbuffers::NativeTable {
  typedef BoolSessionAttribute TableType;
  std::string name;
  bool value;
  BoolSessionAttributeT()
      : value(false) {
  }
};

struct BoolSessionAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolSessionAttributeT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const BoolSessionAttribute *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool mutate_value(bool _value) {
    return SetField<uint8_t>(VT_VALUE, static_cast<uint8_t>(_value), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  BoolSessionAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BoolSessionAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoolSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolSessionAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BoolSessionAttribute::VT_NAME, name);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BoolSessionAttribute::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  BoolSessionAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoolSessionAttributeBuilder &operator=(const BoolSessionAttributeBuilder &);
  flatbuffers::Offset<BoolSessionAttribute> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<BoolSessionAttribute>(end);
    fbb_.Required(o, BoolSessionAttribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<BoolSessionAttribute> CreateBoolSessionAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool value = false) {
  BoolSessionAttributeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoolSessionAttribute> CreateBoolSessionAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool value = false) {
  return com::newrelic::mobile::fbs::CreateBoolSessionAttribute(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      value);
}

flatbuffers::Offset<BoolSessionAttribute> CreateBoolSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const BoolSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StringSessionAttributeT *StringSessionAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StringSessionAttributeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void StringSessionAttribute::UnPackTo(StringSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = value(); if (_e) _o->value = _e->str(); };
}

inline flatbuffers::Offset<StringSessionAttribute> StringSessionAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringSessionAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringSessionAttribute> CreateStringSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const StringSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateString(_o->value) : 0;
  return com::newrelic::mobile::fbs::CreateStringSessionAttribute(
      _fbb,
      _name,
      _value);
}

inline LongSessionAttributeT *LongSessionAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LongSessionAttributeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LongSessionAttribute::UnPackTo(LongSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<LongSessionAttribute> LongSessionAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LongSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLongSessionAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LongSessionAttribute> CreateLongSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const LongSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _fbb.CreateString(_o->name);
  auto _value = _o->value;
  return com::newrelic::mobile::fbs::CreateLongSessionAttribute(
      _fbb,
      _name,
      _value);
}

inline DoubleSessionAttributeT *DoubleSessionAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DoubleSessionAttributeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DoubleSessionAttribute::UnPackTo(DoubleSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<DoubleSessionAttribute> DoubleSessionAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DoubleSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDoubleSessionAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DoubleSessionAttribute> CreateDoubleSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const DoubleSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _fbb.CreateString(_o->name);
  auto _value = _o->value;
  return com::newrelic::mobile::fbs::CreateDoubleSessionAttribute(
      _fbb,
      _name,
      _value);
}

inline BoolSessionAttributeT *BoolSessionAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BoolSessionAttributeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BoolSessionAttribute::UnPackTo(BoolSessionAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<BoolSessionAttribute> BoolSessionAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BoolSessionAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoolSessionAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BoolSessionAttribute> CreateBoolSessionAttribute(flatbuffers::FlatBufferBuilder &_fbb, const BoolSessionAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _fbb.CreateString(_o->name);
  auto _value = _o->value;
  return com::newrelic::mobile::fbs::CreateBoolSessionAttribute(
      _fbb,
      _name,
      _value);
}

}  // namespace fbs
}  // namespace mobile
}  // namespace newrelic
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_SESSIONATTRIBUTES_COM_NEWRELIC_MOBILE_FBS_H_

// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HEXAGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_
#define FLATBUFFERS_GENERATED_HEXAGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

#include "hex_generated.h"
#include "jserror_generated.h"
#include "session-attributes_generated.h"

namespace com {
namespace newrelic {
namespace mobile {
namespace fbs {

struct ApplicationLicense;
struct ApplicationLicenseBuilder;
struct ApplicationLicenseT;

struct ApplicationInfo;
struct ApplicationInfoBuilder;
struct ApplicationInfoT;

struct RequestInformation;
struct RequestInformationBuilder;
struct RequestInformationT;

struct HexAgentData;
struct HexAgentDataBuilder;
struct HexAgentDataT;

enum Platform : uint8_t {
  Platform_Android = 0,
  Platform_iOS = 1,
  Platform_tvOS = 2,
  Platform_watchOS = 3,
  Platform_MIN = Platform_Android,
  Platform_MAX = Platform_watchOS
};

inline const Platform (&EnumValuesPlatform())[4] {
  static const Platform values[] = {
    Platform_Android,
    Platform_iOS,
    Platform_tvOS,
    Platform_watchOS
  };
  return values;
}

inline const char * const *EnumNamesPlatform() {
  static const char * const names[5] = {
    "Android",
    "iOS",
    "tvOS",
    "watchOS",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlatform(Platform e) {
  if (::flatbuffers::IsOutRange(e, Platform_Android, Platform_watchOS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPlatform()[index];
}

enum Framework : uint8_t {
  Framework_Native = 0,
  Framework_ReactNative = 1,
  Framework_MIN = Framework_Native,
  Framework_MAX = Framework_ReactNative
};

inline const Framework (&EnumValuesFramework())[2] {
  static const Framework values[] = {
    Framework_Native,
    Framework_ReactNative
  };
  return values;
}

inline const char * const *EnumNamesFramework() {
  static const char * const names[3] = {
    "Native",
    "ReactNative",
    nullptr
  };
  return names;
}

inline const char *EnumNameFramework(Framework e) {
  if (::flatbuffers::IsOutRange(e, Framework_Native, Framework_ReactNative)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFramework()[index];
}

struct ApplicationLicenseT : public ::flatbuffers::NativeTable {
  typedef ApplicationLicense TableType;
  std::string licenseKey{};
  uint64_t accountId = 0;
  uint64_t clusterAgentId = 0;
};

struct ApplicationLicense FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ApplicationLicenseT NativeTableType;
  typedef ApplicationLicenseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LICENSEKEY = 4,
    VT_ACCOUNTID = 6,
    VT_CLUSTERAGENTID = 8
  };
  const ::flatbuffers::String *licenseKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSEKEY);
  }
  ::flatbuffers::String *mutable_licenseKey() {
    return GetPointer<::flatbuffers::String *>(VT_LICENSEKEY);
  }
  bool KeyCompareLessThan(const ApplicationLicense * const o) const {
    return *licenseKey() < *o->licenseKey();
  }
  int KeyCompareWithValue(const char *_licenseKey) const {
    return strcmp(licenseKey()->c_str(), _licenseKey);
  }
  uint64_t accountId() const {
    return GetField<uint64_t>(VT_ACCOUNTID, 0);
  }
  bool mutate_accountId(uint64_t _accountId = 0) {
    return SetField<uint64_t>(VT_ACCOUNTID, _accountId, 0);
  }
  uint64_t clusterAgentId() const {
    return GetField<uint64_t>(VT_CLUSTERAGENTID, 0);
  }
  bool mutate_clusterAgentId(uint64_t _clusterAgentId = 0) {
    return SetField<uint64_t>(VT_CLUSTERAGENTID, _clusterAgentId, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LICENSEKEY) &&
           verifier.VerifyString(licenseKey()) &&
           VerifyField<uint64_t>(verifier, VT_ACCOUNTID, 8) &&
           VerifyField<uint64_t>(verifier, VT_CLUSTERAGENTID, 8) &&
           verifier.EndTable();
  }
  ApplicationLicenseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationLicenseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ApplicationLicense> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationLicenseBuilder {
  typedef ApplicationLicense Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_licenseKey(::flatbuffers::Offset<::flatbuffers::String> licenseKey) {
    fbb_.AddOffset(ApplicationLicense::VT_LICENSEKEY, licenseKey);
  }
  void add_accountId(uint64_t accountId) {
    fbb_.AddElement<uint64_t>(ApplicationLicense::VT_ACCOUNTID, accountId, 0);
  }
  void add_clusterAgentId(uint64_t clusterAgentId) {
    fbb_.AddElement<uint64_t>(ApplicationLicense::VT_CLUSTERAGENTID, clusterAgentId, 0);
  }
  explicit ApplicationLicenseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ApplicationLicense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ApplicationLicense>(end);
    fbb_.Required(o, ApplicationLicense::VT_LICENSEKEY);
    return o;
  }
};

inline ::flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> licenseKey = 0,
    uint64_t accountId = 0,
    uint64_t clusterAgentId = 0) {
  ApplicationLicenseBuilder builder_(_fbb);
  builder_.add_clusterAgentId(clusterAgentId);
  builder_.add_accountId(accountId);
  builder_.add_licenseKey(licenseKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ApplicationLicense> CreateApplicationLicenseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *licenseKey = nullptr,
    uint64_t accountId = 0,
    uint64_t clusterAgentId = 0) {
  auto licenseKey__ = licenseKey ? _fbb.CreateString(licenseKey) : 0;
  return com::newrelic::mobile::fbs::CreateApplicationLicense(
      _fbb,
      licenseKey__,
      accountId,
      clusterAgentId);
}

::flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplicationInfoT : public ::flatbuffers::NativeTable {
  typedef ApplicationInfo TableType;
  std::unique_ptr<com::newrelic::mobile::fbs::ApplicationLicenseT> applicationLicense{};
  com::newrelic::mobile::fbs::Platform platform = com::newrelic::mobile::fbs::Platform_Android;
  std::string appVersion{};
  uint64_t appVersionId = 0;
  com::newrelic::mobile::fbs::Framework framework = com::newrelic::mobile::fbs::Framework_Native;
  ApplicationInfoT() = default;
  ApplicationInfoT(const ApplicationInfoT &o);
  ApplicationInfoT(ApplicationInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  ApplicationInfoT &operator=(ApplicationInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct ApplicationInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ApplicationInfoT NativeTableType;
  typedef ApplicationInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATIONLICENSE = 4,
    VT_PLATFORM = 6,
    VT_APPVERSION = 8,
    VT_APPVERSIONID = 10,
    VT_FRAMEWORK = 12
  };
  const com::newrelic::mobile::fbs::ApplicationLicense *applicationLicense() const {
    return GetPointer<const com::newrelic::mobile::fbs::ApplicationLicense *>(VT_APPLICATIONLICENSE);
  }
  com::newrelic::mobile::fbs::ApplicationLicense *mutable_applicationLicense() {
    return GetPointer<com::newrelic::mobile::fbs::ApplicationLicense *>(VT_APPLICATIONLICENSE);
  }
  com::newrelic::mobile::fbs::Platform platform() const {
    return static_cast<com::newrelic::mobile::fbs::Platform>(GetField<uint8_t>(VT_PLATFORM, 0));
  }
  bool mutate_platform(com::newrelic::mobile::fbs::Platform _platform = static_cast<com::newrelic::mobile::fbs::Platform>(0)) {
    return SetField<uint8_t>(VT_PLATFORM, static_cast<uint8_t>(_platform), 0);
  }
  const ::flatbuffers::String *appVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPVERSION);
  }
  ::flatbuffers::String *mutable_appVersion() {
    return GetPointer<::flatbuffers::String *>(VT_APPVERSION);
  }
  uint64_t appVersionId() const {
    return GetField<uint64_t>(VT_APPVERSIONID, 0);
  }
  bool mutate_appVersionId(uint64_t _appVersionId = 0) {
    return SetField<uint64_t>(VT_APPVERSIONID, _appVersionId, 0);
  }
  com::newrelic::mobile::fbs::Framework framework() const {
    return static_cast<com::newrelic::mobile::fbs::Framework>(GetField<uint8_t>(VT_FRAMEWORK, 0));
  }
  bool mutate_framework(com::newrelic::mobile::fbs::Framework _framework = static_cast<com::newrelic::mobile::fbs::Framework>(0)) {
    return SetField<uint8_t>(VT_FRAMEWORK, static_cast<uint8_t>(_framework), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPLICATIONLICENSE) &&
           verifier.VerifyTable(applicationLicense()) &&
           VerifyField<uint8_t>(verifier, VT_PLATFORM, 1) &&
           VerifyOffset(verifier, VT_APPVERSION) &&
           verifier.VerifyString(appVersion()) &&
           VerifyField<uint64_t>(verifier, VT_APPVERSIONID, 8) &&
           VerifyField<uint8_t>(verifier, VT_FRAMEWORK, 1) &&
           verifier.EndTable();
  }
  ApplicationInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ApplicationInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationInfoBuilder {
  typedef ApplicationInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_applicationLicense(::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationLicense> applicationLicense) {
    fbb_.AddOffset(ApplicationInfo::VT_APPLICATIONLICENSE, applicationLicense);
  }
  void add_platform(com::newrelic::mobile::fbs::Platform platform) {
    fbb_.AddElement<uint8_t>(ApplicationInfo::VT_PLATFORM, static_cast<uint8_t>(platform), 0);
  }
  void add_appVersion(::flatbuffers::Offset<::flatbuffers::String> appVersion) {
    fbb_.AddOffset(ApplicationInfo::VT_APPVERSION, appVersion);
  }
  void add_appVersionId(uint64_t appVersionId) {
    fbb_.AddElement<uint64_t>(ApplicationInfo::VT_APPVERSIONID, appVersionId, 0);
  }
  void add_framework(com::newrelic::mobile::fbs::Framework framework) {
    fbb_.AddElement<uint8_t>(ApplicationInfo::VT_FRAMEWORK, static_cast<uint8_t>(framework), 0);
  }
  explicit ApplicationInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ApplicationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ApplicationInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationLicense> applicationLicense = 0,
    com::newrelic::mobile::fbs::Platform platform = com::newrelic::mobile::fbs::Platform_Android,
    ::flatbuffers::Offset<::flatbuffers::String> appVersion = 0,
    uint64_t appVersionId = 0,
    com::newrelic::mobile::fbs::Framework framework = com::newrelic::mobile::fbs::Framework_Native) {
  ApplicationInfoBuilder builder_(_fbb);
  builder_.add_appVersionId(appVersionId);
  builder_.add_appVersion(appVersion);
  builder_.add_applicationLicense(applicationLicense);
  builder_.add_framework(framework);
  builder_.add_platform(platform);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ApplicationInfo> CreateApplicationInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationLicense> applicationLicense = 0,
    com::newrelic::mobile::fbs::Platform platform = com::newrelic::mobile::fbs::Platform_Android,
    const char *appVersion = nullptr,
    uint64_t appVersionId = 0,
    com::newrelic::mobile::fbs::Framework framework = com::newrelic::mobile::fbs::Framework_Native) {
  auto appVersion__ = appVersion ? _fbb.CreateString(appVersion) : 0;
  return com::newrelic::mobile::fbs::CreateApplicationInfo(
      _fbb,
      applicationLicense,
      platform,
      appVersion__,
      appVersionId,
      framework);
}

::flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestInformationT : public ::flatbuffers::NativeTable {
  typedef RequestInformation TableType;
  uint64_t requestTimestampMs = 0;
  uint32_t requestAddress = 0;
};

struct RequestInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestInformationT NativeTableType;
  typedef RequestInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUESTTIMESTAMPMS = 4,
    VT_REQUESTADDRESS = 6
  };
  uint64_t requestTimestampMs() const {
    return GetField<uint64_t>(VT_REQUESTTIMESTAMPMS, 0);
  }
  bool mutate_requestTimestampMs(uint64_t _requestTimestampMs = 0) {
    return SetField<uint64_t>(VT_REQUESTTIMESTAMPMS, _requestTimestampMs, 0);
  }
  uint32_t requestAddress() const {
    return GetField<uint32_t>(VT_REQUESTADDRESS, 0);
  }
  bool mutate_requestAddress(uint32_t _requestAddress = 0) {
    return SetField<uint32_t>(VT_REQUESTADDRESS, _requestAddress, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTTIMESTAMPMS, 8) &&
           VerifyField<uint32_t>(verifier, VT_REQUESTADDRESS, 4) &&
           verifier.EndTable();
  }
  RequestInformationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestInformationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RequestInformation> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestInformationBuilder {
  typedef RequestInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_requestTimestampMs(uint64_t requestTimestampMs) {
    fbb_.AddElement<uint64_t>(RequestInformation::VT_REQUESTTIMESTAMPMS, requestTimestampMs, 0);
  }
  void add_requestAddress(uint32_t requestAddress) {
    fbb_.AddElement<uint32_t>(RequestInformation::VT_REQUESTADDRESS, requestAddress, 0);
  }
  explicit RequestInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestInformation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestInformation> CreateRequestInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestTimestampMs = 0,
    uint32_t requestAddress = 0) {
  RequestInformationBuilder builder_(_fbb);
  builder_.add_requestTimestampMs(requestTimestampMs);
  builder_.add_requestAddress(requestAddress);
  return builder_.Finish();
}

::flatbuffers::Offset<RequestInformation> CreateRequestInformation(::flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HexAgentDataT : public ::flatbuffers::NativeTable {
  typedef HexAgentData TableType;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::StringSessionAttributeT>> stringAttributes{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::LongSessionAttributeT>> longAttributes{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::DoubleSessionAttributeT>> doubleAttributes{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::BoolSessionAttributeT>> boolAttributes{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::hex::HandledExceptionT>> handledExceptions{};
  std::unique_ptr<com::newrelic::mobile::fbs::ApplicationInfoT> applicationInfo{};
  std::unique_ptr<com::newrelic::mobile::fbs::RequestInformationT> requestInfo{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::jserror::JsErrorT>> jsErrors{};
  HexAgentDataT() = default;
  HexAgentDataT(const HexAgentDataT &o);
  HexAgentDataT(HexAgentDataT&&) FLATBUFFERS_NOEXCEPT = default;
  HexAgentDataT &operator=(HexAgentDataT o) FLATBUFFERS_NOEXCEPT;
};

struct HexAgentData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HexAgentDataT NativeTableType;
  typedef HexAgentDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRINGATTRIBUTES = 4,
    VT_LONGATTRIBUTES = 6,
    VT_DOUBLEATTRIBUTES = 8,
    VT_BOOLATTRIBUTES = 10,
    VT_HANDLEDEXCEPTIONS = 12,
    VT_APPLICATIONINFO = 14,
    VT_REQUESTINFO = 16,
    VT_JSERRORS = 18
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *stringAttributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *>(VT_STRINGATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *mutable_stringAttributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *>(VT_STRINGATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *longAttributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *>(VT_LONGATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *mutable_longAttributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *>(VT_LONGATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *doubleAttributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *>(VT_DOUBLEATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *mutable_doubleAttributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *>(VT_DOUBLEATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *boolAttributes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *>(VT_BOOLATTRIBUTES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *mutable_boolAttributes() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *>(VT_BOOLATTRIBUTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *handledExceptions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *>(VT_HANDLEDEXCEPTIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *mutable_handledExceptions() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *>(VT_HANDLEDEXCEPTIONS);
  }
  const com::newrelic::mobile::fbs::ApplicationInfo *applicationInfo() const {
    return GetPointer<const com::newrelic::mobile::fbs::ApplicationInfo *>(VT_APPLICATIONINFO);
  }
  com::newrelic::mobile::fbs::ApplicationInfo *mutable_applicationInfo() {
    return GetPointer<com::newrelic::mobile::fbs::ApplicationInfo *>(VT_APPLICATIONINFO);
  }
  const com::newrelic::mobile::fbs::RequestInformation *requestInfo() const {
    return GetPointer<const com::newrelic::mobile::fbs::RequestInformation *>(VT_REQUESTINFO);
  }
  com::newrelic::mobile::fbs::RequestInformation *mutable_requestInfo() {
    return GetPointer<com::newrelic::mobile::fbs::RequestInformation *>(VT_REQUESTINFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> *jsErrors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> *>(VT_JSERRORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> *mutable_jsErrors() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> *>(VT_JSERRORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRINGATTRIBUTES) &&
           verifier.VerifyVector(stringAttributes()) &&
           verifier.VerifyVectorOfTables(stringAttributes()) &&
           VerifyOffset(verifier, VT_LONGATTRIBUTES) &&
           verifier.VerifyVector(longAttributes()) &&
           verifier.VerifyVectorOfTables(longAttributes()) &&
           VerifyOffset(verifier, VT_DOUBLEATTRIBUTES) &&
           verifier.VerifyVector(doubleAttributes()) &&
           verifier.VerifyVectorOfTables(doubleAttributes()) &&
           VerifyOffset(verifier, VT_BOOLATTRIBUTES) &&
           verifier.VerifyVector(boolAttributes()) &&
           verifier.VerifyVectorOfTables(boolAttributes()) &&
           VerifyOffset(verifier, VT_HANDLEDEXCEPTIONS) &&
           verifier.VerifyVector(handledExceptions()) &&
           verifier.VerifyVectorOfTables(handledExceptions()) &&
           VerifyOffset(verifier, VT_APPLICATIONINFO) &&
           verifier.VerifyTable(applicationInfo()) &&
           VerifyOffset(verifier, VT_REQUESTINFO) &&
           verifier.VerifyTable(requestInfo()) &&
           VerifyOffset(verifier, VT_JSERRORS) &&
           verifier.VerifyVector(jsErrors()) &&
           verifier.VerifyVectorOfTables(jsErrors()) &&
           verifier.EndTable();
  }
  HexAgentDataT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HexAgentDataT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HexAgentData> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HexAgentDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HexAgentDataBuilder {
  typedef HexAgentData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_stringAttributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>> stringAttributes) {
    fbb_.AddOffset(HexAgentData::VT_STRINGATTRIBUTES, stringAttributes);
  }
  void add_longAttributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>> longAttributes) {
    fbb_.AddOffset(HexAgentData::VT_LONGATTRIBUTES, longAttributes);
  }
  void add_doubleAttributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>> doubleAttributes) {
    fbb_.AddOffset(HexAgentData::VT_DOUBLEATTRIBUTES, doubleAttributes);
  }
  void add_boolAttributes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>> boolAttributes) {
    fbb_.AddOffset(HexAgentData::VT_BOOLATTRIBUTES, boolAttributes);
  }
  void add_handledExceptions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>> handledExceptions) {
    fbb_.AddOffset(HexAgentData::VT_HANDLEDEXCEPTIONS, handledExceptions);
  }
  void add_applicationInfo(::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationInfo> applicationInfo) {
    fbb_.AddOffset(HexAgentData::VT_APPLICATIONINFO, applicationInfo);
  }
  void add_requestInfo(::flatbuffers::Offset<com::newrelic::mobile::fbs::RequestInformation> requestInfo) {
    fbb_.AddOffset(HexAgentData::VT_REQUESTINFO, requestInfo);
  }
  void add_jsErrors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>>> jsErrors) {
    fbb_.AddOffset(HexAgentData::VT_JSERRORS, jsErrors);
  }
  explicit HexAgentDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HexAgentData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HexAgentData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HexAgentData> CreateHexAgentData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>> stringAttributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>> longAttributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>> doubleAttributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>> boolAttributes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>> handledExceptions = 0,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationInfo> applicationInfo = 0,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::RequestInformation> requestInfo = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>>> jsErrors = 0) {
  HexAgentDataBuilder builder_(_fbb);
  builder_.add_jsErrors(jsErrors);
  builder_.add_requestInfo(requestInfo);
  builder_.add_applicationInfo(applicationInfo);
  builder_.add_handledExceptions(handledExceptions);
  builder_.add_boolAttributes(boolAttributes);
  builder_.add_doubleAttributes(doubleAttributes);
  builder_.add_longAttributes(longAttributes);
  builder_.add_stringAttributes(stringAttributes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HexAgentData> CreateHexAgentDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *stringAttributes = nullptr,
    std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *longAttributes = nullptr,
    std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *doubleAttributes = nullptr,
    std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *boolAttributes = nullptr,
    const std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *handledExceptions = nullptr,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::ApplicationInfo> applicationInfo = 0,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::RequestInformation> requestInfo = 0,
    const std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> *jsErrors = nullptr) {
  auto stringAttributes__ = stringAttributes ? _fbb.CreateVectorOfSortedTables<com::newrelic::mobile::fbs::StringSessionAttribute>(stringAttributes) : 0;
  auto longAttributes__ = longAttributes ? _fbb.CreateVectorOfSortedTables<com::newrelic::mobile::fbs::LongSessionAttribute>(longAttributes) : 0;
  auto doubleAttributes__ = doubleAttributes ? _fbb.CreateVectorOfSortedTables<com::newrelic::mobile::fbs::DoubleSessionAttribute>(doubleAttributes) : 0;
  auto boolAttributes__ = boolAttributes ? _fbb.CreateVectorOfSortedTables<com::newrelic::mobile::fbs::BoolSessionAttribute>(boolAttributes) : 0;
  auto handledExceptions__ = handledExceptions ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>(*handledExceptions) : 0;
  auto jsErrors__ = jsErrors ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>>(*jsErrors) : 0;
  return com::newrelic::mobile::fbs::CreateHexAgentData(
      _fbb,
      stringAttributes__,
      longAttributes__,
      doubleAttributes__,
      boolAttributes__,
      handledExceptions__,
      applicationInfo,
      requestInfo,
      jsErrors__);
}

::flatbuffers::Offset<HexAgentData> CreateHexAgentData(::flatbuffers::FlatBufferBuilder &_fbb, const HexAgentDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ApplicationLicenseT *ApplicationLicense::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplicationLicenseT>(new ApplicationLicenseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplicationLicense::UnPackTo(ApplicationLicenseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = licenseKey(); if (_e) _o->licenseKey = _e->str(); }
  { auto _e = accountId(); _o->accountId = _e; }
  { auto _e = clusterAgentId(); _o->clusterAgentId = _e; }
}

inline ::flatbuffers::Offset<ApplicationLicense> ApplicationLicense::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplicationLicense(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ApplicationLicenseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _licenseKey = _fbb.CreateString(_o->licenseKey);
  auto _accountId = _o->accountId;
  auto _clusterAgentId = _o->clusterAgentId;
  return com::newrelic::mobile::fbs::CreateApplicationLicense(
      _fbb,
      _licenseKey,
      _accountId,
      _clusterAgentId);
}

inline ApplicationInfoT::ApplicationInfoT(const ApplicationInfoT &o)
      : applicationLicense((o.applicationLicense) ? new com::newrelic::mobile::fbs::ApplicationLicenseT(*o.applicationLicense) : nullptr),
        platform(o.platform),
        appVersion(o.appVersion),
        appVersionId(o.appVersionId),
        framework(o.framework) {
}

inline ApplicationInfoT &ApplicationInfoT::operator=(ApplicationInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(applicationLicense, o.applicationLicense);
  std::swap(platform, o.platform);
  std::swap(appVersion, o.appVersion);
  std::swap(appVersionId, o.appVersionId);
  std::swap(framework, o.framework);
  return *this;
}

inline ApplicationInfoT *ApplicationInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplicationInfoT>(new ApplicationInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplicationInfo::UnPackTo(ApplicationInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = applicationLicense(); if (_e) { if(_o->applicationLicense) { _e->UnPackTo(_o->applicationLicense.get(), _resolver); } else { _o->applicationLicense = std::unique_ptr<com::newrelic::mobile::fbs::ApplicationLicenseT>(_e->UnPack(_resolver)); } } else if (_o->applicationLicense) { _o->applicationLicense.reset(); } }
  { auto _e = platform(); _o->platform = _e; }
  { auto _e = appVersion(); if (_e) _o->appVersion = _e->str(); }
  { auto _e = appVersionId(); _o->appVersionId = _e; }
  { auto _e = framework(); _o->framework = _e; }
}

inline ::flatbuffers::Offset<ApplicationInfo> ApplicationInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplicationInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ApplicationInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _applicationLicense = _o->applicationLicense ? CreateApplicationLicense(_fbb, _o->applicationLicense.get(), _rehasher) : 0;
  auto _platform = _o->platform;
  auto _appVersion = _o->appVersion.empty() ? 0 : _fbb.CreateString(_o->appVersion);
  auto _appVersionId = _o->appVersionId;
  auto _framework = _o->framework;
  return com::newrelic::mobile::fbs::CreateApplicationInfo(
      _fbb,
      _applicationLicense,
      _platform,
      _appVersion,
      _appVersionId,
      _framework);
}

inline RequestInformationT *RequestInformation::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RequestInformationT>(new RequestInformationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RequestInformation::UnPackTo(RequestInformationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = requestTimestampMs(); _o->requestTimestampMs = _e; }
  { auto _e = requestAddress(); _o->requestAddress = _e; }
}

inline ::flatbuffers::Offset<RequestInformation> RequestInformation::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestInformation(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RequestInformation> CreateRequestInformation(::flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RequestInformationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _requestTimestampMs = _o->requestTimestampMs;
  auto _requestAddress = _o->requestAddress;
  return com::newrelic::mobile::fbs::CreateRequestInformation(
      _fbb,
      _requestTimestampMs,
      _requestAddress);
}

inline HexAgentDataT::HexAgentDataT(const HexAgentDataT &o)
      : applicationInfo((o.applicationInfo) ? new com::newrelic::mobile::fbs::ApplicationInfoT(*o.applicationInfo) : nullptr),
        requestInfo((o.requestInfo) ? new com::newrelic::mobile::fbs::RequestInformationT(*o.requestInfo) : nullptr) {
  stringAttributes.reserve(o.stringAttributes.size());
  for (const auto &stringAttributes_ : o.stringAttributes) { stringAttributes.emplace_back((stringAttributes_) ? new com::newrelic::mobile::fbs::StringSessionAttributeT(*stringAttributes_) : nullptr); }
  longAttributes.reserve(o.longAttributes.size());
  for (const auto &longAttributes_ : o.longAttributes) { longAttributes.emplace_back((longAttributes_) ? new com::newrelic::mobile::fbs::LongSessionAttributeT(*longAttributes_) : nullptr); }
  doubleAttributes.reserve(o.doubleAttributes.size());
  for (const auto &doubleAttributes_ : o.doubleAttributes) { doubleAttributes.emplace_back((doubleAttributes_) ? new com::newrelic::mobile::fbs::DoubleSessionAttributeT(*doubleAttributes_) : nullptr); }
  boolAttributes.reserve(o.boolAttributes.size());
  for (const auto &boolAttributes_ : o.boolAttributes) { boolAttributes.emplace_back((boolAttributes_) ? new com::newrelic::mobile::fbs::BoolSessionAttributeT(*boolAttributes_) : nullptr); }
  handledExceptions.reserve(o.handledExceptions.size());
  for (const auto &handledExceptions_ : o.handledExceptions) { handledExceptions.emplace_back((handledExceptions_) ? new com::newrelic::mobile::fbs::hex::HandledExceptionT(*handledExceptions_) : nullptr); }
  jsErrors.reserve(o.jsErrors.size());
  for (const auto &jsErrors_ : o.jsErrors) { jsErrors.emplace_back((jsErrors_) ? new com::newrelic::mobile::fbs::jserror::JsErrorT(*jsErrors_) : nullptr); }
}

inline HexAgentDataT &HexAgentDataT::operator=(HexAgentDataT o) FLATBUFFERS_NOEXCEPT {
  std::swap(stringAttributes, o.stringAttributes);
  std::swap(longAttributes, o.longAttributes);
  std::swap(doubleAttributes, o.doubleAttributes);
  std::swap(boolAttributes, o.boolAttributes);
  std::swap(handledExceptions, o.handledExceptions);
  std::swap(applicationInfo, o.applicationInfo);
  std::swap(requestInfo, o.requestInfo);
  std::swap(jsErrors, o.jsErrors);
  return *this;
}

inline HexAgentDataT *HexAgentData::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HexAgentDataT>(new HexAgentDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HexAgentData::UnPackTo(HexAgentDataT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stringAttributes(); if (_e) { _o->stringAttributes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->stringAttributes[_i]) { _e->Get(_i)->UnPackTo(_o->stringAttributes[_i].get(), _resolver); } else { _o->stringAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::StringSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->stringAttributes.resize(0); } }
  { auto _e = longAttributes(); if (_e) { _o->longAttributes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->longAttributes[_i]) { _e->Get(_i)->UnPackTo(_o->longAttributes[_i].get(), _resolver); } else { _o->longAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::LongSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->longAttributes.resize(0); } }
  { auto _e = doubleAttributes(); if (_e) { _o->doubleAttributes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->doubleAttributes[_i]) { _e->Get(_i)->UnPackTo(_o->doubleAttributes[_i].get(), _resolver); } else { _o->doubleAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::DoubleSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->doubleAttributes.resize(0); } }
  { auto _e = boolAttributes(); if (_e) { _o->boolAttributes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->boolAttributes[_i]) { _e->Get(_i)->UnPackTo(_o->boolAttributes[_i].get(), _resolver); } else { _o->boolAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::BoolSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->boolAttributes.resize(0); } }
  { auto _e = handledExceptions(); if (_e) { _o->handledExceptions.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->handledExceptions[_i]) { _e->Get(_i)->UnPackTo(_o->handledExceptions[_i].get(), _resolver); } else { _o->handledExceptions[_i] = std::unique_ptr<com::newrelic::mobile::fbs::hex::HandledExceptionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->handledExceptions.resize(0); } }
  { auto _e = applicationInfo(); if (_e) { if(_o->applicationInfo) { _e->UnPackTo(_o->applicationInfo.get(), _resolver); } else { _o->applicationInfo = std::unique_ptr<com::newrelic::mobile::fbs::ApplicationInfoT>(_e->UnPack(_resolver)); } } else if (_o->applicationInfo) { _o->applicationInfo.reset(); } }
  { auto _e = requestInfo(); if (_e) { if(_o->requestInfo) { _e->UnPackTo(_o->requestInfo.get(), _resolver); } else { _o->requestInfo = std::unique_ptr<com::newrelic::mobile::fbs::RequestInformationT>(_e->UnPack(_resolver)); } } else if (_o->requestInfo) { _o->requestInfo.reset(); } }
  { auto _e = jsErrors(); if (_e) { _o->jsErrors.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->jsErrors[_i]) { _e->Get(_i)->UnPackTo(_o->jsErrors[_i].get(), _resolver); } else { _o->jsErrors[_i] = std::unique_ptr<com::newrelic::mobile::fbs::jserror::JsErrorT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->jsErrors.resize(0); } }
}

inline ::flatbuffers::Offset<HexAgentData> HexAgentData::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HexAgentDataT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHexAgentData(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HexAgentData> CreateHexAgentData(::flatbuffers::FlatBufferBuilder &_fbb, const HexAgentDataT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HexAgentDataT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stringAttributes = _o->stringAttributes.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> (_o->stringAttributes.size(), [](size_t i, _VectorArgs *__va) { return CreateStringSessionAttribute(*__va->__fbb, __va->__o->stringAttributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _longAttributes = _o->longAttributes.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> (_o->longAttributes.size(), [](size_t i, _VectorArgs *__va) { return CreateLongSessionAttribute(*__va->__fbb, __va->__o->longAttributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _doubleAttributes = _o->doubleAttributes.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> (_o->doubleAttributes.size(), [](size_t i, _VectorArgs *__va) { return CreateDoubleSessionAttribute(*__va->__fbb, __va->__o->doubleAttributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _boolAttributes = _o->boolAttributes.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> (_o->boolAttributes.size(), [](size_t i, _VectorArgs *__va) { return CreateBoolSessionAttribute(*__va->__fbb, __va->__o->boolAttributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _handledExceptions = _o->handledExceptions.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> (_o->handledExceptions.size(), [](size_t i, _VectorArgs *__va) { return CreateHandledException(*__va->__fbb, __va->__o->handledExceptions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _applicationInfo = _o->applicationInfo ? CreateApplicationInfo(_fbb, _o->applicationInfo.get(), _rehasher) : 0;
  auto _requestInfo = _o->requestInfo ? CreateRequestInformation(_fbb, _o->requestInfo.get(), _rehasher) : 0;
  auto _jsErrors = _o->jsErrors.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::jserror::JsError>> (_o->jsErrors.size(), [](size_t i, _VectorArgs *__va) { return CreateJsError(*__va->__fbb, __va->__o->jsErrors[i].get(), __va->__rehasher); }, &_va ) : 0;
  return com::newrelic::mobile::fbs::CreateHexAgentData(
      _fbb,
      _stringAttributes,
      _longAttributes,
      _doubleAttributes,
      _boolAttributes,
      _handledExceptions,
      _applicationInfo,
      _requestInfo,
      _jsErrors);
}

inline const com::newrelic::mobile::fbs::HexAgentData *GetHexAgentData(const void *buf) {
  return ::flatbuffers::GetRoot<com::newrelic::mobile::fbs::HexAgentData>(buf);
}

inline const com::newrelic::mobile::fbs::HexAgentData *GetSizePrefixedHexAgentData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<com::newrelic::mobile::fbs::HexAgentData>(buf);
}

inline HexAgentData *GetMutableHexAgentData(void *buf) {
  return ::flatbuffers::GetMutableRoot<HexAgentData>(buf);
}

inline com::newrelic::mobile::fbs::HexAgentData *GetMutableSizePrefixedHexAgentData(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<com::newrelic::mobile::fbs::HexAgentData>(buf);
}

inline bool VerifyHexAgentDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<com::newrelic::mobile::fbs::HexAgentData>(nullptr);
}

inline bool VerifySizePrefixedHexAgentDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<com::newrelic::mobile::fbs::HexAgentData>(nullptr);
}

inline void FinishHexAgentDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::HexAgentData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedHexAgentDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::HexAgentData> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<com::newrelic::mobile::fbs::HexAgentDataT> UnPackHexAgentData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<com::newrelic::mobile::fbs::HexAgentDataT>(GetHexAgentData(buf)->UnPack(res));
}

inline std::unique_ptr<com::newrelic::mobile::fbs::HexAgentDataT> UnPackSizePrefixedHexAgentData(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<com::newrelic::mobile::fbs::HexAgentDataT>(GetSizePrefixedHexAgentData(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace mobile
}  // namespace newrelic
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_HEXAGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_

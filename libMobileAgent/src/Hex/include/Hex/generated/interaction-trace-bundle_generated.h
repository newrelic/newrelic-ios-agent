// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INTERACTIONTRACEBUNDLE_COM_NEWRELIC_MOBILE_FBS_MODELS_H_
#define FLATBUFFERS_GENERATED_INTERACTIONTRACEBUNDLE_COM_NEWRELIC_MOBILE_FBS_MODELS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

namespace com {
namespace newrelic {
namespace mobile {
namespace fbs {
namespace models {

struct InteractionTraceBundle;
struct InteractionTraceBundleBuilder;
struct InteractionTraceBundleT;

struct InteractionTrace;
struct InteractionTraceBuilder;
struct InteractionTraceT;

struct InteractionTraceBundleT : public ::flatbuffers::NativeTable {
  typedef InteractionTraceBundle TableType;
  int32_t accountId = 0;
  uint64_t appId = 0;
  int32_t appVersionId = 0;
  std::string countryCode{};
  std::string device{};
  std::string os{};
  std::string entityGuid{};
  std::string dispatcher{};
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceT>> interactionTraces{};
  InteractionTraceBundleT() = default;
  InteractionTraceBundleT(const InteractionTraceBundleT &o);
  InteractionTraceBundleT(InteractionTraceBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  InteractionTraceBundleT &operator=(InteractionTraceBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct InteractionTraceBundle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InteractionTraceBundleT NativeTableType;
  typedef InteractionTraceBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCOUNTID = 4,
    VT_APPID = 6,
    VT_APPVERSIONID = 8,
    VT_COUNTRYCODE = 10,
    VT_DEVICE = 12,
    VT_OS = 14,
    VT_ENTITYGUID = 16,
    VT_DISPATCHER = 18,
    VT_INTERACTIONTRACES = 20
  };
  int32_t accountId() const {
    return GetField<int32_t>(VT_ACCOUNTID, 0);
  }
  bool mutate_accountId(int32_t _accountId = 0) {
    return SetField<int32_t>(VT_ACCOUNTID, _accountId, 0);
  }
  uint64_t appId() const {
    return GetField<uint64_t>(VT_APPID, 0);
  }
  bool mutate_appId(uint64_t _appId = 0) {
    return SetField<uint64_t>(VT_APPID, _appId, 0);
  }
  int32_t appVersionId() const {
    return GetField<int32_t>(VT_APPVERSIONID, 0);
  }
  bool mutate_appVersionId(int32_t _appVersionId = 0) {
    return SetField<int32_t>(VT_APPVERSIONID, _appVersionId, 0);
  }
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  ::flatbuffers::String *mutable_countryCode() {
    return GetPointer<::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  const ::flatbuffers::String *device() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEVICE);
  }
  ::flatbuffers::String *mutable_device() {
    return GetPointer<::flatbuffers::String *>(VT_DEVICE);
  }
  const ::flatbuffers::String *os() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OS);
  }
  ::flatbuffers::String *mutable_os() {
    return GetPointer<::flatbuffers::String *>(VT_OS);
  }
  const ::flatbuffers::String *entityGuid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENTITYGUID);
  }
  ::flatbuffers::String *mutable_entityGuid() {
    return GetPointer<::flatbuffers::String *>(VT_ENTITYGUID);
  }
  const ::flatbuffers::String *dispatcher() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPATCHER);
  }
  ::flatbuffers::String *mutable_dispatcher() {
    return GetPointer<::flatbuffers::String *>(VT_DISPATCHER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> *interactionTraces() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> *>(VT_INTERACTIONTRACES);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> *mutable_interactionTraces() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> *>(VT_INTERACTIONTRACES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACCOUNTID, 4) &&
           VerifyField<uint64_t>(verifier, VT_APPID, 8) &&
           VerifyField<int32_t>(verifier, VT_APPVERSIONID, 4) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyOffset(verifier, VT_DEVICE) &&
           verifier.VerifyString(device()) &&
           VerifyOffset(verifier, VT_OS) &&
           verifier.VerifyString(os()) &&
           VerifyOffset(verifier, VT_ENTITYGUID) &&
           verifier.VerifyString(entityGuid()) &&
           VerifyOffset(verifier, VT_DISPATCHER) &&
           verifier.VerifyString(dispatcher()) &&
           VerifyOffset(verifier, VT_INTERACTIONTRACES) &&
           verifier.VerifyVector(interactionTraces()) &&
           verifier.VerifyVectorOfTables(interactionTraces()) &&
           verifier.EndTable();
  }
  InteractionTraceBundleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractionTraceBundleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InteractionTraceBundle> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceBundleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractionTraceBundleBuilder {
  typedef InteractionTraceBundle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_accountId(int32_t accountId) {
    fbb_.AddElement<int32_t>(InteractionTraceBundle::VT_ACCOUNTID, accountId, 0);
  }
  void add_appId(uint64_t appId) {
    fbb_.AddElement<uint64_t>(InteractionTraceBundle::VT_APPID, appId, 0);
  }
  void add_appVersionId(int32_t appVersionId) {
    fbb_.AddElement<int32_t>(InteractionTraceBundle::VT_APPVERSIONID, appVersionId, 0);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(InteractionTraceBundle::VT_COUNTRYCODE, countryCode);
  }
  void add_device(::flatbuffers::Offset<::flatbuffers::String> device) {
    fbb_.AddOffset(InteractionTraceBundle::VT_DEVICE, device);
  }
  void add_os(::flatbuffers::Offset<::flatbuffers::String> os) {
    fbb_.AddOffset(InteractionTraceBundle::VT_OS, os);
  }
  void add_entityGuid(::flatbuffers::Offset<::flatbuffers::String> entityGuid) {
    fbb_.AddOffset(InteractionTraceBundle::VT_ENTITYGUID, entityGuid);
  }
  void add_dispatcher(::flatbuffers::Offset<::flatbuffers::String> dispatcher) {
    fbb_.AddOffset(InteractionTraceBundle::VT_DISPATCHER, dispatcher);
  }
  void add_interactionTraces(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>>> interactionTraces) {
    fbb_.AddOffset(InteractionTraceBundle::VT_INTERACTIONTRACES, interactionTraces);
  }
  explicit InteractionTraceBundleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InteractionTraceBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InteractionTraceBundle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InteractionTraceBundle> CreateInteractionTraceBundle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t accountId = 0,
    uint64_t appId = 0,
    int32_t appVersionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> device = 0,
    ::flatbuffers::Offset<::flatbuffers::String> os = 0,
    ::flatbuffers::Offset<::flatbuffers::String> entityGuid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dispatcher = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>>> interactionTraces = 0) {
  InteractionTraceBundleBuilder builder_(_fbb);
  builder_.add_appId(appId);
  builder_.add_interactionTraces(interactionTraces);
  builder_.add_dispatcher(dispatcher);
  builder_.add_entityGuid(entityGuid);
  builder_.add_os(os);
  builder_.add_device(device);
  builder_.add_countryCode(countryCode);
  builder_.add_appVersionId(appVersionId);
  builder_.add_accountId(accountId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InteractionTraceBundle> CreateInteractionTraceBundleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t accountId = 0,
    uint64_t appId = 0,
    int32_t appVersionId = 0,
    const char *countryCode = nullptr,
    const char *device = nullptr,
    const char *os = nullptr,
    const char *entityGuid = nullptr,
    const char *dispatcher = nullptr,
    const std::vector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> *interactionTraces = nullptr) {
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto device__ = device ? _fbb.CreateString(device) : 0;
  auto os__ = os ? _fbb.CreateString(os) : 0;
  auto entityGuid__ = entityGuid ? _fbb.CreateString(entityGuid) : 0;
  auto dispatcher__ = dispatcher ? _fbb.CreateString(dispatcher) : 0;
  auto interactionTraces__ = interactionTraces ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>>(*interactionTraces) : 0;
  return com::newrelic::mobile::fbs::models::CreateInteractionTraceBundle(
      _fbb,
      accountId,
      appId,
      appVersionId,
      countryCode__,
      device__,
      os__,
      entityGuid__,
      dispatcher__,
      interactionTraces__);
}

::flatbuffers::Offset<InteractionTraceBundle> CreateInteractionTraceBundle(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceBundleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InteractionTraceT : public ::flatbuffers::NativeTable {
  typedef InteractionTrace TableType;
  uint64_t start = 0;
  uint64_t end = 0;
  std::string name{};
  float duration = 0.0f;
  std::string protocolVersion{};
  std::string content{};
};

struct InteractionTrace FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InteractionTraceT NativeTableType;
  typedef InteractionTraceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_END = 6,
    VT_NAME = 8,
    VT_DURATION = 10,
    VT_PROTOCOLVERSION = 12,
    VT_CONTENT = 14
  };
  uint64_t start() const {
    return GetField<uint64_t>(VT_START, 0);
  }
  bool mutate_start(uint64_t _start = 0) {
    return SetField<uint64_t>(VT_START, _start, 0);
  }
  uint64_t end() const {
    return GetField<uint64_t>(VT_END, 0);
  }
  bool mutate_end(uint64_t _end = 0) {
    return SetField<uint64_t>(VT_END, _end, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ::flatbuffers::String *mutable_name() {
    return GetPointer<::flatbuffers::String *>(VT_NAME);
  }
  float duration() const {
    return GetField<float>(VT_DURATION, 0.0f);
  }
  bool mutate_duration(float _duration = 0.0f) {
    return SetField<float>(VT_DURATION, _duration, 0.0f);
  }
  const ::flatbuffers::String *protocolVersion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROTOCOLVERSION);
  }
  ::flatbuffers::String *mutable_protocolVersion() {
    return GetPointer<::flatbuffers::String *>(VT_PROTOCOLVERSION);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  ::flatbuffers::String *mutable_content() {
    return GetPointer<::flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START, 8) &&
           VerifyField<uint64_t>(verifier, VT_END, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_DURATION, 4) &&
           VerifyOffset(verifier, VT_PROTOCOLVERSION) &&
           verifier.VerifyString(protocolVersion()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           verifier.EndTable();
  }
  InteractionTraceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InteractionTraceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<InteractionTrace> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InteractionTraceBuilder {
  typedef InteractionTrace Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start(uint64_t start) {
    fbb_.AddElement<uint64_t>(InteractionTrace::VT_START, start, 0);
  }
  void add_end(uint64_t end) {
    fbb_.AddElement<uint64_t>(InteractionTrace::VT_END, end, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(InteractionTrace::VT_NAME, name);
  }
  void add_duration(float duration) {
    fbb_.AddElement<float>(InteractionTrace::VT_DURATION, duration, 0.0f);
  }
  void add_protocolVersion(::flatbuffers::Offset<::flatbuffers::String> protocolVersion) {
    fbb_.AddOffset(InteractionTrace::VT_PROTOCOLVERSION, protocolVersion);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(InteractionTrace::VT_CONTENT, content);
  }
  explicit InteractionTraceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InteractionTrace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InteractionTrace>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InteractionTrace> CreateInteractionTrace(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start = 0,
    uint64_t end = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    float duration = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> protocolVersion = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0) {
  InteractionTraceBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_content(content);
  builder_.add_protocolVersion(protocolVersion);
  builder_.add_duration(duration);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InteractionTrace> CreateInteractionTraceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start = 0,
    uint64_t end = 0,
    const char *name = nullptr,
    float duration = 0.0f,
    const char *protocolVersion = nullptr,
    const char *content = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto protocolVersion__ = protocolVersion ? _fbb.CreateString(protocolVersion) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  return com::newrelic::mobile::fbs::models::CreateInteractionTrace(
      _fbb,
      start,
      end,
      name__,
      duration,
      protocolVersion__,
      content__);
}

::flatbuffers::Offset<InteractionTrace> CreateInteractionTrace(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InteractionTraceBundleT::InteractionTraceBundleT(const InteractionTraceBundleT &o)
      : accountId(o.accountId),
        appId(o.appId),
        appVersionId(o.appVersionId),
        countryCode(o.countryCode),
        device(o.device),
        os(o.os),
        entityGuid(o.entityGuid),
        dispatcher(o.dispatcher) {
  interactionTraces.reserve(o.interactionTraces.size());
  for (const auto &interactionTraces_ : o.interactionTraces) { interactionTraces.emplace_back((interactionTraces_) ? new com::newrelic::mobile::fbs::models::InteractionTraceT(*interactionTraces_) : nullptr); }
}

inline InteractionTraceBundleT &InteractionTraceBundleT::operator=(InteractionTraceBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(accountId, o.accountId);
  std::swap(appId, o.appId);
  std::swap(appVersionId, o.appVersionId);
  std::swap(countryCode, o.countryCode);
  std::swap(device, o.device);
  std::swap(os, o.os);
  std::swap(entityGuid, o.entityGuid);
  std::swap(dispatcher, o.dispatcher);
  std::swap(interactionTraces, o.interactionTraces);
  return *this;
}

inline InteractionTraceBundleT *InteractionTraceBundle::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractionTraceBundleT>(new InteractionTraceBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractionTraceBundle::UnPackTo(InteractionTraceBundleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = accountId(); _o->accountId = _e; }
  { auto _e = appId(); _o->appId = _e; }
  { auto _e = appVersionId(); _o->appVersionId = _e; }
  { auto _e = countryCode(); if (_e) _o->countryCode = _e->str(); }
  { auto _e = device(); if (_e) _o->device = _e->str(); }
  { auto _e = os(); if (_e) _o->os = _e->str(); }
  { auto _e = entityGuid(); if (_e) _o->entityGuid = _e->str(); }
  { auto _e = dispatcher(); if (_e) _o->dispatcher = _e->str(); }
  { auto _e = interactionTraces(); if (_e) { _o->interactionTraces.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->interactionTraces[_i]) { _e->Get(_i)->UnPackTo(_o->interactionTraces[_i].get(), _resolver); } else { _o->interactionTraces[_i] = std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->interactionTraces.resize(0); } }
}

inline ::flatbuffers::Offset<InteractionTraceBundle> InteractionTraceBundle::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceBundleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractionTraceBundle(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InteractionTraceBundle> CreateInteractionTraceBundle(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceBundleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InteractionTraceBundleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _accountId = _o->accountId;
  auto _appId = _o->appId;
  auto _appVersionId = _o->appVersionId;
  auto _countryCode = _o->countryCode.empty() ? 0 : _fbb.CreateString(_o->countryCode);
  auto _device = _o->device.empty() ? 0 : _fbb.CreateString(_o->device);
  auto _os = _o->os.empty() ? 0 : _fbb.CreateString(_o->os);
  auto _entityGuid = _o->entityGuid.empty() ? 0 : _fbb.CreateString(_o->entityGuid);
  auto _dispatcher = _o->dispatcher.empty() ? 0 : _fbb.CreateString(_o->dispatcher);
  auto _interactionTraces = _o->interactionTraces.size() ? _fbb.CreateVector<::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTrace>> (_o->interactionTraces.size(), [](size_t i, _VectorArgs *__va) { return CreateInteractionTrace(*__va->__fbb, __va->__o->interactionTraces[i].get(), __va->__rehasher); }, &_va ) : 0;
  return com::newrelic::mobile::fbs::models::CreateInteractionTraceBundle(
      _fbb,
      _accountId,
      _appId,
      _appVersionId,
      _countryCode,
      _device,
      _os,
      _entityGuid,
      _dispatcher,
      _interactionTraces);
}

inline InteractionTraceT *InteractionTrace::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InteractionTraceT>(new InteractionTraceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InteractionTrace::UnPackTo(InteractionTraceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start(); _o->start = _e; }
  { auto _e = end(); _o->end = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = duration(); _o->duration = _e; }
  { auto _e = protocolVersion(); if (_e) _o->protocolVersion = _e->str(); }
  { auto _e = content(); if (_e) _o->content = _e->str(); }
}

inline ::flatbuffers::Offset<InteractionTrace> InteractionTrace::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInteractionTrace(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<InteractionTrace> CreateInteractionTrace(::flatbuffers::FlatBufferBuilder &_fbb, const InteractionTraceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InteractionTraceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start = _o->start;
  auto _end = _o->end;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _duration = _o->duration;
  auto _protocolVersion = _o->protocolVersion.empty() ? 0 : _fbb.CreateString(_o->protocolVersion);
  auto _content = _o->content.empty() ? 0 : _fbb.CreateString(_o->content);
  return com::newrelic::mobile::fbs::models::CreateInteractionTrace(
      _fbb,
      _start,
      _end,
      _name,
      _duration,
      _protocolVersion,
      _content);
}

inline const com::newrelic::mobile::fbs::models::InteractionTraceBundle *GetInteractionTraceBundle(const void *buf) {
  return ::flatbuffers::GetRoot<com::newrelic::mobile::fbs::models::InteractionTraceBundle>(buf);
}

inline const com::newrelic::mobile::fbs::models::InteractionTraceBundle *GetSizePrefixedInteractionTraceBundle(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<com::newrelic::mobile::fbs::models::InteractionTraceBundle>(buf);
}

inline InteractionTraceBundle *GetMutableInteractionTraceBundle(void *buf) {
  return ::flatbuffers::GetMutableRoot<InteractionTraceBundle>(buf);
}

inline com::newrelic::mobile::fbs::models::InteractionTraceBundle *GetMutableSizePrefixedInteractionTraceBundle(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<com::newrelic::mobile::fbs::models::InteractionTraceBundle>(buf);
}

inline bool VerifyInteractionTraceBundleBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<com::newrelic::mobile::fbs::models::InteractionTraceBundle>(nullptr);
}

inline bool VerifySizePrefixedInteractionTraceBundleBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<com::newrelic::mobile::fbs::models::InteractionTraceBundle>(nullptr);
}

inline void FinishInteractionTraceBundleBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTraceBundle> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedInteractionTraceBundleBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<com::newrelic::mobile::fbs::models::InteractionTraceBundle> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceBundleT> UnPackInteractionTraceBundle(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceBundleT>(GetInteractionTraceBundle(buf)->UnPack(res));
}

inline std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceBundleT> UnPackSizePrefixedInteractionTraceBundle(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<com::newrelic::mobile::fbs::models::InteractionTraceBundleT>(GetSizePrefixedInteractionTraceBundle(buf)->UnPack(res));
}

}  // namespace models
}  // namespace fbs
}  // namespace mobile
}  // namespace newrelic
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_INTERACTIONTRACEBUNDLE_COM_NEWRELIC_MOBILE_FBS_MODELS_H_
